# Python file with all essential functions used during CiliateAnnotation program execution
import subprocess
import sys
from settings import *
from functools import reduce
#------------------------------------------------------------------------------------------------------------------------------------------------------------------

# This function runs rough BLAST and returns the hsp result list

def run_Rough_BLAST(Output_dir, contig):
	# Set up parameters
	param = ("blastn -task " + Options['RoughBlastTask'] + " -word_size " + str(Options['RoughBlastWordSize']) + " -max_hsps 0 -max_target_seqs 10000 -dust").split(" ")
	
	if Options['RoughBlastDust']:
		param.append("yes")
	else:
		param.append("no")
	if Options['RoughBlastUngapped']:
		param.append("-ungapped")
	if Options['BlastMaskLowercase']:
		param.append("-lcase_masking")

	param.append("-query")
	param.append(Output_dir + "/Masked_Contigs/" + str(contig) + ".fa")
	param.append("-db")
	param.append(Output_dir + "/blast/mic")
	param.append("-num_threads")
	param.append(str(Options['ThreadCount']))
	param.append("-outfmt")
	param.append("10 qseqid sseqid pident length mismatch qstart qend sstart send evalue bitscore qcovs")	

	# Run BLAST command
	rough_out = subprocess.check_output(param)
	
	# Filter empty rows
	roughVal = [x.rstrip() for x in rough_out.decode(sys.stdout.encoding).split('\n') if x != "" and float(x.rstrip().split(",")[11]) >= 3]
	# Check if there are any hsps
	if not roughVal:
		return ""
	
	# Save rough results to file
	rough_file = open(Output_dir + '/hsp/rough/' + contig + '.csv', 'w')
	for x in roughVal[:-1]:
		rough_file.write(x + '\n')
	rough_file.write(roughVal[-1])	
	rough_file.close()
	
	# Filter duplicates out and parse result
	res = [x.split(',') for x in list(set(roughVal))]
	
	return res
	
#------------------------------------------------------------------------------------------------------------------------------------------------------------------

# This function runs fine BLAST and returns hsp result list

def run_Fine_BLAST(Output_dir, contig):
	param = ("blastn -task " + Options['FineBlastTask'] + " -word_size " + str(Options['FineBlastWordSize']) + " -max_hsps 0 -max_target_seqs 10000 -dust").split(" ")
 	
	if Options['FineBlastDust']:
		param.append("yes")
	else:
		param.append("no")
	if Options['FineBlastUngapped']:
		param.append("-ungapped")
	if Options['BlastMaskLowercase']:
		param.append("-lcase_masking")
	
	param.append("-query")
	param.append(Output_dir + "/Masked_Contigs/" + str(contig) + ".fa")
	param.append("-db")
	param.append(Output_dir + "/blast/mic")
	param.append("-num_threads")
	param.append(str(Options['ThreadCount']))
	param.append("-outfmt")
	param.append("10 qseqid sseqid pident length mismatch qstart qend sstart send evalue bitscore qcovs")

	fine_out = subprocess.check_output(param)
	
	# Filter empty rows
	fineVal = [x.rstrip() for x in fine_out.decode(sys.stdout.encoding).split('\n') if x != "" and float(x.rstrip().split(",")[11]) >= 3]
	# Check if there are any hsps
	if not fineVal:
		return ""
	
	# Save fine results to file
	fine_file = open(Output_dir + '/hsp/fine/' + str(contig) + '.csv', 'w')
	for x in fineVal[:-1]:
		fine_file.write(x + "\n")
	fine_file.write(fineVal[-1])
	fine_file.close()
	
	# Filter duplicates out and parse result
	res = [x.split(',') for x in list(set(fineVal))]
	
	return res
	
#------------------------------------------------------------------------------------------------------------------------------------------------------------------

# This function reads hsp file that was generated by run_Rough_BLAST or run_Fine_BLAST functions previously
def readBLAST_file(Filename):
	# Initialize list to read input
	res = list()
	
	# Read file line by line
	for line in open(Filename, "r"):
		# Parse and append line into the res list 
		res.append(line.rstrip().split(","))
		
	# Return list if it not empty and empty string otherwise
	if res:
		return res
	else:
		return ""
#------------------------------------------------------------------------------------------------------------------------------------------------------------------

# This function goes through the list of high scoring pairs that are associated with the MIC and constructs MDSs for the MAC

def getMDS_Annotation(MDS_List, HSP_List, MAC_start, MAC_end):
	# Get Gaps List
	Gaps = getGapsList(MDS_List, MAC_start, MAC_end)
		
	# Build list of MDSs
	for hsp in HSP_List:
		mds_toAdd = [int(hsp[5]), int(hsp[6]),0]
				
		# If current MDS does not overlap with any gap, then skip it
		if not [x for x in Gaps if x[1] > mds_toAdd[0] and x[0] < mds_toAdd[1]]:
			continue
		
		# Go through MDSs that overlap with current MDS and see if any can be merged or removed
		for x in sorted([mds for mds in MDS_List if mds[1] > mds_toAdd[0] and mds[0] < mds_toAdd[1]]):
			# If x is a subset of mds_toAdd, then remove x
			if x[0] >= mds_toAdd[0] and x[1] <= mds_toAdd[1]:
				MDS_List.remove(x)
			# Check if two MDSs can be merged
			elif int((mds_toAdd[0] + mds_toAdd[1])/2) in range(x[0], x[1]) or int((x[0] + x[1])/2) in range(mds_toAdd[0], mds_toAdd[1]):
				mds_toAdd[0] = min(mds_toAdd[0], x[0])
				mds_toAdd[1] = max(mds_toAdd[1], x[1])
				MDS_List.remove(x)
		
		# Add MDS to the MDS list, update gaps list, check if we are done
		MDS_List.append(mds_toAdd)
		Gaps = getGapsList(MDS_List, MAC_start, MAC_end)
		if not Gaps:
			break
	
	# Sort the MDS List
	MDS_List.sort(key=lambda x: x[0])		

#------------------------------------------------------------------------------------------------------------------------------------------------------------------
# This function takes a list of MDSs (sorted by the MDS begining coordinate) and returns the intervals of the MAC covering

def getCovering_Intervals(MDS_List):
	# Construct intervals by using MDS List and checking for gaps between consecutive MDSs
	MAC_Interval = list()
	for mds in sorted(MDS_List, key = lambda x: x[0]):
		if not MAC_Interval:
			MAC_Interval.append([mds[0], mds[1]])
		else:
			if MAC_Interval[-1][1] >= mds[0] - 1:
				MAC_Interval[-1][1] = max(mds[1], MAC_Interval[-1][1])
			else:
				MAC_Interval.append([mds[0], mds[1]])
	
	return MAC_Interval
				
#------------------------------------------------------------------------------------------------------------------------------------------------------------------

# This function checks whether there are any gaps in the MAC annotation

def addGaps(MDS_List, MAC_start, MAC_end):
	# If MDS List is empty, then return the whole MAC interval as a gap
	if not MDS_List:
		MDS_List.append([MAC_start, MAC_end, 1])
		return
	
	# Get the list of covered MAC Interval(s)
	MAC_Interval = getCovering_Intervals(MDS_List)
		
	# If we have more than one interval, then there are gaps we need to add to the annotation
	if len(MAC_Interval) > 1:
		prev = MAC_Interval[0]
		for interv in MAC_Interval[1:]:
			MDS_List.append([prev[1], interv[0],1])
			prev = interv
			
	# Check for gaps at the begining of MAC and at the end of MAC
	if MAC_Interval[0][0] - MAC_start > 1:
		MDS_List.append([MAC_start, MAC_Interval[0][0], 1])
	if MAC_end - MAC_Interval[-1][1] > 1:
		MDS_List.append([MAC_Interval[-1][1], MAC_end, 1])
#------------------------------------------------------------------------------------------------------------------------------------------------------------------

# This function assigns MDS number to hsps that correspond to some MDS in MAC

def mapHSP_to_MDS(MIC_maps, MDS_List):
	# Go through the list of hsps and assign MDS number, or -1 to each hsp
	for hsp in MIC_maps:
		# Set hsp to no MDS for now
		hsp.append(-1)
			
		# Get list of MDSs that were mapped from current hsp
		overlap = [x for x in MDS_List if (x[2] != 1) and (int(hsp[5]) < x[1] and int(hsp[6]) > x[0])]
		if not overlap:
			continue
			
		# Define reduce function to decide what MDS the hsp is going to match the best (has biggest overlap)
		match = lambda a, b: a if min(a[1], int(hsp[6])) - max(a[0], int(hsp[5])) > min(b[1], int(hsp[6])) - max(b[0], int(hsp[5])) else b
		matched_MDS = reduce(match, overlap)
		
		# Assign hsp to MDS
		hsp[-1] = matched_MDS[-1]
#------------------------------------------------------------------------------------------------------------------------------------------------------------------

# This function calculates the list of gaps in the MAC annotation
		
def getGapsList(MDS_List, MAC_start, MAC_end):
	# If no MDS, return the whole contig interval
	if not MDS_List:
		return [[MAC_start, MAC_end]]
	
	# Sort MDS list
	MDS_List.sort(key=lambda x: x[0])
	
	# Add gap at the begining, if needed
	Gaps = list()
	if MDS_List[0][0] - MAC_start > 1:
		Gaps.append([MAC_start, MDS_List[0][0]])
	
	# If there are more than one MDS, then add gaps in between MDSs
	if len(MDS_List) > 1:
		prev = MDS_List[0]
		for x in MDS_List[1:]:
			if x[0] - prev[1] > 1:
				Gaps.append([prev[1], x[0]])
			prev = x
	
	# Check if there is a gap at the end	
	if MAC_end - MDS_List[-1][1] > 1:
		Gaps.append([MDS_List[-1][1], MAC_end])
		
	return Gaps
#------------------------------------------------------------------------------------------------------------------------------------------------------------------

# This function outputs annotation results into the database load file

def updateDatabaseInput(MDS_List, MIC_maps, left_Tel, right_Tel, mac_length, Output_dir, contig):
	# If MIC_maps are not empty, then update hsp file
	if MIC_maps:
		# Open hsp file to append
		hspFile = open(Output_dir + '/Database_Input/hsp.tsv', 'a')
		
		# Output hsps to file
		for hsp in MIC_maps:
			# Update hsp ID
			updateDatabaseInput.hspID += 1
			
			# Get MIC start, end, and orientation
			micStart = hsp[7]
			micEnd = hsp[8]
			micOrient = "+"
			if int(hsp[7]) > int(hsp[8]):
				micStart = hsp[8]
				micEnd = hsp[7]
				micOrient = "-"
			
			# Print hsp
			hspFile.write(str(updateDatabaseInput.hspID) + "\t" + hsp[0] + "\t\\N\t" + str(hsp[-1]) + "\t" + hsp[5] + "\t" + hsp[6] + "\t" + hsp[1] + 
			"\t\\N\t" + micStart + "\t" + micEnd + "\t" + micOrient + "\t" + hsp[3] + "\t" + hsp[2] + "\t" + hsp[4] + "\t" + hsp[9] + "\t" + hsp[10] + 
			"\t" + hsp[11] + "\n")
		
		# close hsp file
		hspFile.close()
	
	# If MDS list is not empty, then update mds file
	if MDS_List:
		# Open mds file to append
		mdsFile = open(Output_dir + '/Database_Input/mds.tsv', 'a')
		
		# Output mdss to file
		for mds in MDS_List:
			# Update mds ID
			updateDatabaseInput.mdsID += 1
			
			#Print mds
			mdsFile.write(str(updateDatabaseInput.mdsID) + "\t\\N\t" + str(contig) + "\t" + str(mds[-1]) + "\t" + str(mds[0]) + "\t" + 
			str(mds[1]) + "\t" + str(mds[1] - mds[0] + 1) + "\t" + str(mds[2]) + "\n")
		
		# Close mds file
		mdsFile.close()
		
	# Update telomeres file
	updateDatabaseInput.telID += 1
	telFile = open(Output_dir + '/Database_Input/tel.tsv', 'a')
	
	# Get number of telomeres
	tel_num = 0
	if left_Tel:
		tel_num += 1
	if right_Tel:
		tel_num += 1
	
	# Output to file
	telFile.write(str(updateDatabaseInput.telID) + "\t\\N\t" + str(contig) + "\t" + str(mac_length) + "\t" + str(tel_num) + "\t")
	# Info about left telomere
	if left_Tel:
		telFile.write(str(left_Tel[0]+1) + "\t" + str(left_Tel[1]+1) + "\t" + str(left_Tel[1] - left_Tel[0] + 1) + "\t")
	else:
		telFile.write("NULL\tNULL\t0\t")
	# infor about right telomere
	if right_Tel:
		telFile.write(str(right_Tel[0]+1) + "\t" + str(right_Tel[1]+1) + "\t" + str(right_Tel[1] - right_Tel[0] + 1) + "\n")
	else:
		telFile.write("NULL\tNULL\t0\n")	
		
	telFile.close()
	
# Static variables for updateDatabaseInput function
updateDatabaseInput.hspID = 0
updateDatabaseInput.mdsID = 0	
updateDatabaseInput.telID = 0
#------------------------------------------------------------------------------------------------------------------------------------------------------------------

# This function sorts hsp list

def sortHSP_List(MIC_maps):
		# Define sort function that will sort by:
		# 1) Higher Coverage, 2) Higher Length, 3) Higher Persent  identity match, 4) Lower Bitscore, 5) MIC, 6) the hsp start position in the MAC
		sort_func = key=lambda x: (float(x[11]), int(x[3]), float(x[2]), -float(x[10]), x[1], -int(x[5]))
		
		# Run sort
		MIC_maps.sort(key = sort_func, reverse=True)
	
	
	
	
	
	
	
	
	
	
	
	